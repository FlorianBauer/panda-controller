//============================================================================
/// \file    RobotControllerImpl.cpp
/// \authors Florian Bauer <florian.bauer.dev@gmail.com>
/// \date    2021-01-26
/// \brief   Definition of the CRobotControllerImpl class
/// \note    Code generated by sila2codegenerator 0.3.3-dev
//============================================================================

#include "RobotControllerImpl.h"

#include <fstream>
#include <vector>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <nlohmann/json.hpp>
#include <sila_cpp/common/logging.h>
#include <sila_cpp/framework/error_handling/ExecutionError.h>
#include "FileManager.h"
#include "RobotController.pb.h"

using namespace sila2::de::fau::robot::robotcontroller::v1;
using moveit::planning_interface::MoveItErrorCode;


CRobotControllerImpl::CRobotControllerImpl(SiLA2::CSiLAServer* parent,
        const std::shared_ptr<CSiteManagerImpl> siteManagerPtr,
        const std::shared_ptr<CPlateTypeManagerImpl> plateTypeManagerPtr)
: CSiLAFeature{parent},
m_SiteManagerPtr{siteManagerPtr},
m_PlateTypeManagerPtr{plateTypeManagerPtr},
m_GetCurrentFrameCommand{this, "GetCurrentFrame"},
m_GetCurrentPoseCommand{this, "GetCurrentPose"},
m_MoveToPoseCommand{this, "MoveToPose"},
m_MoveToSiteCommand{this, "MoveToSite"},
m_MoveRelativeCommand{this, "MoveRelative"},
m_TransportPlateCommand{this, "TransportPlate"},
m_PickPlateCommand{this, "PickPlate"},
m_PlacePlateCommand{this, "PlacePlate"},
m_IsSiteOccupiedCommand{this, "IsSiteOccupied"},
m_FollowPathCommand{this, "FollowPath"},
m_SetToFrameCommand{this, "SetToFrame"},
m_FollowFramesCommand{this, "FollowFrames"},
m_SetGripperCommand{this, "SetGripper"},
m_CloseGripperCommand{this, "CloseGripper"}
{
    m_Arm.setGoalOrientationTolerance(0.05);
    m_GetCurrentFrameCommand.setExecutor(this, &CRobotControllerImpl::GetCurrentFrame);
    m_GetCurrentPoseCommand.setExecutor(this, &CRobotControllerImpl::GetCurrentPose);
    m_MoveToPoseCommand.setExecutor(this, &CRobotControllerImpl::MoveToPose);
    m_MoveToSiteCommand.setExecutor(this, &CRobotControllerImpl::MoveToSite);
    m_MoveRelativeCommand.setExecutor(this, &CRobotControllerImpl::MoveRelative);
    m_TransportPlateCommand.setExecutor(this, &CRobotControllerImpl::TransportPlate);
    m_PickPlateCommand.setExecutor(this, &CRobotControllerImpl::PickPlate);
    m_PlacePlateCommand.setExecutor(this, &CRobotControllerImpl::PlacePlate);
    m_IsSiteOccupiedCommand.setExecutor(this, &CRobotControllerImpl::IsSiteOccupied);
    m_FollowPathCommand.setExecutor(this, &CRobotControllerImpl::FollowPath);
    m_SetToFrameCommand.setExecutor(this, &CRobotControllerImpl::SetToFrame);
    m_FollowFramesCommand.setExecutor(this, &CRobotControllerImpl::FollowFrames);
    m_SetGripperCommand.setExecutor(this, &CRobotControllerImpl::SetGripper);
    m_CloseGripperCommand.setExecutor(this, &CRobotControllerImpl::CloseGripper);
}

/**
 * Get the current frame of the robot. A frame consists of the absolute values of all joints.
 * 
 * @param command The SiLA command.
 * @return The values of all robot joints.
 */
GetCurrentFrame_Responses CRobotControllerImpl::GetCurrentFrame(GetCurrentFrameWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const std::vector<double> joints = m_Arm.getCurrentJointValues();
    auto response = GetCurrentFrame_Responses{};
    const auto frame = response.mutable_frame();
    for (size_t i = 0; i < MAX_JOINTS; i++) {
        const auto joint = frame->add_frame();
        joint->set_value(joints[i]);
    }
    return response;
}

/**
 * Get the current Pose (position + orientation as quaternion) of the end-effector.
 * 
 * @param command The SiLA command.
 * @return The pose consist of position (xyz) and orientation (xyzw).
 */
GetCurrentPose_Responses CRobotControllerImpl::GetCurrentPose(GetCurrentPoseWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const geometry_msgs::PoseStamped curPose = m_Arm.getCurrentPose(PANDA_LINK_EEF);
    const Pose retPose = {
        .X = curPose.pose.position.x,
        .Y = curPose.pose.position.y,
        .Z = curPose.pose.position.z,
        .OriX = curPose.pose.orientation.x,
        .OriY = curPose.pose.orientation.y,
        .OriZ = curPose.pose.orientation.z,
        .OriW = curPose.pose.orientation.w
    };

    auto response = GetCurrentPose_Responses{};
    response.set_allocated_pose(retPose.toProtoMessagePtr());
    return response;
}

/**
 * Moves the robot end-effector to the given pose. Since path planning is active on this request, 
 * an invalid pose or an pose causing a collision will throw a validation error.
 * 
 * @param command The SiLA command.
 * @return A empty response.
 */
MoveToPose_Responses CRobotControllerImpl::MoveToPose(MoveToPoseWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const auto& pose = request.pose().pose();
    geometry_msgs::Pose targetPose;
    targetPose.position.x = pose.x().value();
    targetPose.position.y = pose.y().value();
    targetPose.position.z = pose.z().value();
    targetPose.orientation.x = pose.orix().value();
    targetPose.orientation.y = pose.oriy().value();
    targetPose.orientation.z = pose.oriz().value();
    targetPose.orientation.w = pose.oriw().value();
    m_Arm.setPoseTarget(targetPose, PANDA_LINK_EEF);
    const MoveItErrorCode err = m_Arm.move();
    if (err != MoveItErrorCode::SUCCESS) {
        throw ERROR_INVALID_POSE;
    }

    return MoveToPose_Responses{};
}

MoveToSite_Responses CRobotControllerImpl::MoveToSite(MoveToSiteWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const std::string& siteId = request.siteid().siteid().value();
    if (!m_SiteManagerPtr->hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    const Site site = m_SiteManagerPtr->getSite(siteId);
    m_Arm.setPoseTarget(site.getPose(), PANDA_LINK_EEF);
    const MoveItErrorCode err = m_Arm.move();
    if (err != MoveItErrorCode::SUCCESS) {
        throw ERROR_INVALID_POSE;
    }

    return MoveToSite_Responses{};
}

MoveRelative_Responses CRobotControllerImpl::MoveRelative(MoveRelativeWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    // TODO: Validate request parameters...

    return MoveRelative_Responses{};
}

TransportPlate_Responses CRobotControllerImpl::TransportPlate(TransportPlateWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    // TODO: Validate request parameters...

    // TODO: Write actual Command implementation logic...
    const double NUM_STEPS = 10.0;
    for (int i = 0; i <= NUM_STEPS; ++i) {
        // do stuff...
        command->setExecutionInfo(SiLA2::CReal{i / NUM_STEPS});
    }

    auto Response = TransportPlate_Responses{};
    // TODO: Fill the response fields
    return Response;
}

PickPlate_Responses CRobotControllerImpl::PickPlate(PickPlateWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& siteId = request.siteid().siteid().value();
    if (!m_SiteManagerPtr->hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    const std::string& plateTypeId = request.platetypeid().value();
    if (!m_PlateTypeManagerPtr->hasPlateTypeId(plateTypeId)) {
        throw ERROR_PLATE_TYPE_ID_NOT_FOUND;
    }

    if (m_IsOnTransport) {
        throw SiLA2::CExecutionError("Gripper is already holding a plate.");
    }

    Site site = m_SiteManagerPtr->getSite(siteId);
    m_TransportedPlatePtr = m_PlateTypeManagerPtr->createSharedPlate(plateTypeId);
    m_TransportedPlatePtr->putAtSite(site);
    m_PlanningScene.applyCollisionObject(m_TransportedPlatePtr->getCollisonObject());
    moveit_msgs::Grasp grasp = site.getGrasp();
    openGripper(grasp.pre_grasp_posture, m_TransportedPlatePtr->getDimY());
    closeGripper(grasp.grasp_posture);
    command->setExecutionInfo(SiLA2::CReal{0.5});
    const MoveItErrorCode err = m_Arm.pick(m_TransportedPlatePtr->getObjectId(), grasp);
    if (err != MoveItErrorCode::SUCCESS) {
        throw SiLA2::CExecutionError("Could not pick plate.");
    }
    m_IsOnTransport = true;
    site.setOccupied(false);
    command->executionFinished(SiLA2::CommandStatus::FINISHED_SUCCESSFULLY);

    return PickPlate_Responses{};
}

PlacePlate_Responses CRobotControllerImpl::PlacePlate(PlacePlateWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& siteId = request.siteid().siteid().value();
    if (!m_SiteManagerPtr->hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    if (!m_IsOnTransport) {
        throw SiLA2::CExecutionError("Nothing to place.");
    }

    Site site = m_SiteManagerPtr->getSite(siteId);
    moveit_msgs::Grasp grasp = site.getGrasp();
    openGripper(grasp.pre_grasp_posture, m_TransportedPlatePtr->getDimY());
    command->setExecutionInfo(SiLA2::CReal{0.5});
    const MoveItErrorCode err = m_Arm.place(m_TransportedPlatePtr->getObjectId(), {
        site.getPlaceLocation()
    });
    if (err != MoveItErrorCode::SUCCESS) {
        throw SiLA2::CExecutionError("Could not place plate.");
    }
    m_TransportedPlatePtr->putAtSite(site);
    m_IsOnTransport = false;
    command->executionFinished(SiLA2::CommandStatus::FINISHED_SUCCESSFULLY);

    return PlacePlate_Responses{};
}

IsSiteOccupied_Responses CRobotControllerImpl::IsSiteOccupied(IsSiteOccupiedWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    // TODO: Validate request parameters...

    // TODO: Write actual Command implementation logic...

    auto response = IsSiteOccupied_Responses{};
    // TODO: Fill the response fields
    return response;
}

FollowPath_Responses CRobotControllerImpl::FollowPath(FollowPathWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    double progress = 0.0;
    const auto& poseList = request.poselist();
    geometry_msgs::Pose targetPose;
    for (const auto& pose : poseList) {
        targetPose.position.x = pose.pose().x().value();
        targetPose.position.y = pose.pose().y().value();
        targetPose.position.z = pose.pose().z().value();
        targetPose.orientation.x = pose.pose().orix().value();
        targetPose.orientation.y = pose.pose().oriy().value();
        targetPose.orientation.z = pose.pose().oriz().value();
        targetPose.orientation.w = pose.pose().oriw().value();

        command->setExecutionInfo(SiLA2::CReal{++progress / poseList.size()});
        m_Arm.setPoseTarget(targetPose, PANDA_LINK_EEF);
        const MoveItErrorCode err = m_Arm.move();
        if (err != MoveItErrorCode::SUCCESS) {
            throw ERROR_INVALID_POSE;
        }
    }
    command->executionFinished(SiLA2::CommandStatus::FINISHED_SUCCESSFULLY);

    return FollowPath_Responses{};
}

/**
 * Sets all joints of the robot to the requested values. No checks or path planning is done.
 * 
 * @param command The SiLA command.
 * @return A empty response.
 */
SetToFrame_Responses CRobotControllerImpl::SetToFrame(SetToFrameWrapper* command) {
    const auto& request = command->parameters();
    qDebug() << "Request contains:" << request;
    const auto& frame = request.frame().frame();
    std::vector<double> jointValues(MAX_JOINTS);
    for (size_t i = 0; i < jointValues.size(); i++) {
        jointValues[i] = frame.at(i).value();
    }

    m_Arm.setJointValueTarget(jointValues);
    const MoveItErrorCode err = m_Arm.move();
    if (err != MoveItErrorCode::SUCCESS) {
        throw ERROR_INVALID_FRAME;
    }

    return SetToFrame_Responses{};
}

FollowFrames_Responses CRobotControllerImpl::FollowFrames(FollowFramesWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    double progress = 0.0;
    std::vector<double> jointValues(MAX_JOINTS);
    const auto& frameList = request.framelist();
    for (const auto& frame : frameList) {
        for (size_t i = 0; i < jointValues.size(); i++) {
            jointValues[i] = frame.frame().at(i).value();
        }

        command->setExecutionInfo(SiLA2::CReal{++progress / frameList.size()});
        m_Arm.setJointValueTarget(jointValues);
        const MoveItErrorCode err = m_Arm.move();
        if (err != MoveItErrorCode::SUCCESS) {
            throw ERROR_INVALID_FRAME;
        }
    }
    command->executionFinished(SiLA2::CommandStatus::FINISHED_SUCCESSFULLY);

    return FollowFrames_Responses{};
}

/**
 * Opens the gripper to the given amount + 5 mm extra space.
 * 
 * @param posture The posture to apply the operation on.
 * @param width The width in m to open the gripper.
 */
void CRobotControllerImpl::openGripper(trajectory_msgs::JointTrajectory& posture, double width) {
    posture.points.resize(1);
    posture.points[0].positions.resize(2);
    posture.points[0].positions[0] = width / 2.0 + 0.005;
    posture.points[0].positions[1] = width / 2.0 + 0.005;
    posture.points[0].time_from_start = ros::Duration(0.5);
}

/**
 * Closes the gripper.
 * 
 * @param posture The posture to apply the operation on.
 */
void CRobotControllerImpl::closeGripper(trajectory_msgs::JointTrajectory& posture) {
    posture.points.resize(1);
    posture.points[0].positions.resize(2);
    posture.points[0].positions[0] = 0.00;
    posture.points[0].positions[1] = 0.00;
    posture.points[0].time_from_start = ros::Duration(0.5);
}

SetGripper_Responses CRobotControllerImpl::SetGripper(SetGripperWrapper* command) {
    const auto& request = command->parameters();
    qDebug() << "Request contains:" << request;

    const double halfWidthInM = request.width().value() / 2.0 / 100.0;
    m_Gripper.setJointValueTarget(std::vector<double>{halfWidthInM, halfWidthInM});
    const MoveItErrorCode err = m_Gripper.move();
    if (err != MoveItErrorCode::SUCCESS) {
        throw SiLA2::CExecutionError("Could not set gripper.");
    }

    return SetGripper_Responses{};
}

CloseGripper_Responses CRobotControllerImpl::CloseGripper(CloseGripperWrapper* command) {
    m_Gripper.setJointValueTarget(std::vector<double>{0.0, 0.0});
    const MoveItErrorCode err = m_Gripper.move();
    if (err != MoveItErrorCode::SUCCESS) {
        throw SiLA2::CExecutionError("Could not close gripper.");
    }

    return CloseGripper_Responses{};
}
