//============================================================================
/// \file    PlateTypeManagerImpl.cpp
/// \authors Florian Bauer <florian.bauer.dev@gmail.com>
/// \date    2021-01-26
/// \brief   Declaration of the CPlateTypeManagerImpl class
/// \note    Code generated by sila2codegenerator 0.3.3-dev
//============================================================================

#include "PlateTypeManagerImpl.h"

#include <fstream>
#include <sila_cpp/common/logging.h>
#include "FileManager.h"
#include "Plate.h"

namespace fs = std::filesystem;
using namespace sila2::de::fau::robot::platetypemanager::v1;
using json = nlohmann::json;

constexpr double CM_TO_M = 0.01;

/**
 * Loads the JSON formatted labware files from the `labware` directory into a map.
 * 
 * @return A map where the plate type is the key and the json struct the value.
 */
std::map<std::string, json> CPlateTypeManagerImpl::loadLabwareFilesToMap() {
    const fs::path appDir = FileManager::getAppDir();
    const fs::path labwareDir = appDir / LABWARE_DIR;
    FileManager::checkAndCreateDir(labwareDir);

    std::map<std::string, json> labwares;
    const std::vector<fs::path> labwareFiles = FileManager::collectJsonFilesFromDir(labwareDir);
    for (const auto& file : labwareFiles) {
        // read a JSON file
        std::ifstream jsonStream(file);
        json jsonStruct;
        try {
            jsonStream >> jsonStruct;
            const std::string& id = jsonStruct[Plate::PLATE_TYPE_ID].get<std::string>();
            labwares[id] = jsonStruct;
        } catch (const std::exception& ex) {
            jsonStream.close();
            std::cerr << "Could not load: " << file << "\n" << ex.what() << "\n";
            continue;
        }
        jsonStream.close();
    }
    return labwares;
}

CPlateTypeManagerImpl::CPlateTypeManagerImpl(SiLA2::CSiLAServer* parent)
: CSiLAFeature{parent},
m_GetPlateTypeCommand{this, "GetPlateType"},
m_SetPlateTypeCommand{this, "SetPlateType"},
m_DeletePlateTypeCommand{this, "DeletePlateType"},
m_PlateTypesProperty{this, "PlateTypes"}

,
m_JsonLabwares(loadLabwareFilesToMap()),
m_LabwareDir(FileManager::getAppDir() / LABWARE_DIR) {

    std::vector<SiLA2::CString> plateTypes;
    for (auto const& elem : m_JsonLabwares) {
        // collect IDs
        plateTypes.push_back(SiLA2::CString(elem.first));
    }
    m_PlateTypesProperty.setValue(plateTypes);
    m_GetPlateTypeCommand.setExecutor(this, &CPlateTypeManagerImpl::GetPlateType);
    m_SetPlateTypeCommand.setExecutor(this, &CPlateTypeManagerImpl::SetPlateType);
    m_DeletePlateTypeCommand.setExecutor(this, &CPlateTypeManagerImpl::DeletePlateType);
}

GetPlateType_Responses CPlateTypeManagerImpl::GetPlateType(GetPlateTypeWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const std::string& plateTypeId = request.platetypeid().platetypeid().value();
    const auto iter = m_JsonLabwares.find(plateTypeId);
    const bool isIdInList = (iter != m_JsonLabwares.cend());
    if (!isIdInList) {
        throw ERROR_PLATE_TYPE_ID_NOT_FOUND;
    }

    /* FIXME: temporary hack to show values as string. Implement proper sila struct when 
     * sila2codegenerator is able to generate stubs properly.
     * (2021-01-27, florian.bauer.dev@gmail.com)
     */
    auto response = GetPlateType_Responses{};
    response.mutable_platetype()->set_value(iter->second.dump());
    return response;
}

SetPlateType_Responses CPlateTypeManagerImpl::SetPlateType(SetPlateTypeWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& idToSet = request.platetypeid().platetypeid().value();
    const auto iter = m_JsonLabwares.find(idToSet);
    json jsonStruct;
    const bool isIdInList = (iter != m_JsonLabwares.cend());
    if (!isIdInList) {
        // Add a new ID to property list.
        m_PlateTypesProperty.append(request.platetypeid().platetypeid());
    }

    jsonStruct = {
        {Plate::PLATE_TYPE_ID, idToSet},
        {Plate::DIM_X, request.dimx().value() * CM_TO_M},
        {Plate::DIM_Y, request.dimy().value() * CM_TO_M},
        {Plate::DIM_Z, request.dimz().value() * CM_TO_M},
        {Plate::GRIPPER_OFFSET_X, request.offx().value() * CM_TO_M},
        {Plate::GRIPPER_OFFSET_Y, request.offy().value() * CM_TO_M},
        {Plate::GRIPPER_OFFSET_Z, request.offz().value() * CM_TO_M},
    };

    // Add/update entry in map.
    m_JsonLabwares[idToSet] = jsonStruct;

    // Write JSON data to file.
    const fs::path jsonFile = m_LabwareDir / (idToSet + JSON_FILE_EXT);
    FileManager::saveJsonToFile(jsonStruct, jsonFile);

    return SetPlateType_Responses{};
}

DeletePlateType_Responses CPlateTypeManagerImpl::DeletePlateType(DeletePlateTypeWrapper * command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& idToDelete = request.platetypeid().platetypeid().value();
    const auto iter = m_JsonLabwares.find(idToDelete);
    const bool isIdInList = (iter != m_JsonLabwares.cend());

    if (!isIdInList) {
        throw ERROR_PLATE_TYPE_ID_NOT_FOUND;
    }

    m_JsonLabwares.erase(iter);
    std::vector<SiLA2::CString> plateIds;
    for (auto const& elem : m_JsonLabwares) {
        // collect IDs
        plateIds.push_back(SiLA2::CString(elem.first));
    }
    m_PlateTypesProperty.setValue(plateIds);
    const fs::path jsonFile = m_LabwareDir / (idToDelete + JSON_FILE_EXT);
    fs::remove(jsonFile);

    return DeletePlateType_Responses{};
}

/**
 * Checks whether the given plate type ID is available or not.
 * 
 * @param plateTypeId The ID to check.
 * @return true if the ID exists, otherwise false.
 */
bool CPlateTypeManagerImpl::hasPlateTypeId(const std::string& plateTypeId) const {
    return (m_JsonLabwares.find(plateTypeId) != m_JsonLabwares.cend());
}

Plate CPlateTypeManagerImpl::createPlate(const std::string& plateTypeId) const {
    const std::map<std::string, json>::const_iterator iter = m_JsonLabwares.find(plateTypeId);
    return Plate{iter->second};
}

std::shared_ptr<Plate> CPlateTypeManagerImpl::createSharedPlate(const std::string& plateTypeId) const {
    const std::map<std::string, json>::const_iterator iter = m_JsonLabwares.find(plateTypeId);
    return std::make_shared<Plate>(iter->second);
}
