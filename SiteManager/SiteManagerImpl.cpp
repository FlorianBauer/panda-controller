//============================================================================
/// \file    SiteManagerImpl.cpp
/// \authors Florian Bauer <florian.bauer.dev@gmail.com>
/// \date    2021-01-26
/// \brief   Definition of the CSiteManagerImpl class
/// \note    Code generated by sila2codegenerator 0.3.3-dev
//============================================================================

#include "SiteManagerImpl.h"

#include <iostream>
#include <fstream>
#include <sila_cpp/common/logging.h>
#include "FileManager.h"
#include "ServiceDefs.h"
#include "SiteManager.pb.h"

namespace fs = std::filesystem;
using namespace sila2::de::fau::robot::sitemanager::v1;
using json = nlohmann::json;

constexpr double CM_TO_M = 0.01;
const fs::path CSiteManagerImpl::m_SitesDir{FileManager::getAppDir() / SITES_DIR};
const fs::path CSiteManagerImpl::m_ColObjDir{FileManager::getAppDir() / COLLISION_OBJECTS_DIR};

/**
 *  Loads the JSON formatted site files from the `site` directory into a map.
 * 
 * @param[out] sites The map where the loaded sites get put in.
 */
void CSiteManagerImpl::loadSiteFilesIntoMap(std::map<std::string, Site>& sites) {
    const std::vector<fs::path> siteFiles = FileManager::collectJsonFilesFromDir(m_SitesDir);
    for (const auto& file : siteFiles) {
        // read a JSON file
        std::ifstream jsonStream(file);
        json jsonStruct;
        try {
            jsonStream >> jsonStruct;
            const std::string& id = jsonStruct[Site::SITE_ID].get<std::string>();
            sites.insert({id, Site(jsonStruct)});
        } catch (const std::exception& ex) {
            jsonStream.close();
            std::cerr << "Could not load: " << file << "\n" << ex.what() << "\n";
            continue;
        }
        jsonStream.close();
    }
}

/**
 * Loads the JSON formatted collision object files from the `collision_objects` directory into the
 * planning scene. The files have to be created manually and must be placed in the mentioned 
 * directory.
 * 
 * Example of an collision object file named `wall.json`.
 * ```
 * {
 *     "id": "wall",
 *     "posX": 0.79,
 *     "posY": -0.715,
 *     "posZ": 0.55,
 *     "rotP": 0.0,
 *     "rotR": 0.0,
 *     "rotY": 0.0,
 *     "dimX": 1.0,
 *     "dimY": 0.39,
 *     "dimZ": 2.5
 * }
 * ```
 * 
 * @param planningScene The planning scene to load the objects into.
 */
void CSiteManagerImpl::loadCollisionObjectsIntoScene(moveit::planning_interface::PlanningSceneInterface& planningScene) {
    const std::vector<fs::path> colFiles = FileManager::collectJsonFilesFromDir(m_ColObjDir);
    if (colFiles.empty()) {
        return;
    }

    std::vector<moveit_msgs::CollisionObject> colObjs;
    colObjs.resize(colFiles.size());

    for (const auto& file : colFiles) {
        // read a JSON file
        std::ifstream jsonStream(file);
        json jsonStruct;
        try {
            jsonStream >> jsonStruct;
        } catch (const std::exception& ex) {
            std::cerr << "Could not load: " << file << "\n" << ex.what() << "\n";
            jsonStream.close();
            continue;
        }
        jsonStream.close();
        std::cout << "Loaded: " << jsonStruct["id"] << " from " << file << "\n";

        moveit_msgs::CollisionObject colBox;
        colBox.id = jsonStruct["id"].get<std::string>();
        colBox.header.frame_id = PANDA_LINK_BASE;
        colBox.primitives.resize(1);
        colBox.primitives[0].type = shape_msgs::SolidPrimitive::BOX;
        colBox.primitive_poses.resize(1);
        colBox.primitive_poses[0].position.x = jsonStruct["posX"];
        colBox.primitive_poses[0].position.y = jsonStruct["posY"];
        colBox.primitive_poses[0].position.z = jsonStruct["posZ"];

        tf2::Quaternion orientation;
        orientation.setRPY(jsonStruct["rotR"], jsonStruct["rotP"], jsonStruct["rotY"]);
        colBox.primitive_poses[0].orientation = tf2::toMsg(orientation);

        colBox.primitives[0].dimensions.resize(3);
        colBox.primitives[0].dimensions[0] = jsonStruct["dimX"]; // length;
        colBox.primitives[0].dimensions[1] = jsonStruct["dimY"]; // width
        colBox.primitives[0].dimensions[2] = jsonStruct["dimZ"]; // hight
        colBox.operation = moveit_msgs::CollisionObject::ADD;
        colObjs.push_back(colBox);
    }
    planningScene.applyCollisionObjects(colObjs);
}

CSiteManagerImpl::CSiteManagerImpl(SiLA2::CSiLAServer* parent,
        const std::shared_ptr<CPlateTypeManagerImpl> plateTypeManagerPtr)
: CSiLAFeature{parent},
m_PlateTypeManagerPtr{plateTypeManagerPtr},
m_GetSiteCommand{this, "GetSite"},
m_SetSiteCommand{this, "SetSite"},
m_DeleteSiteCommand{this, "DeleteSite"},
m_IsSiteOccupiedCommand{this, "IsSiteOccupied"},
m_PutPlateOnSiteCommand{this, "PutPlateToSite"},
m_RemovePlateFromSiteCommand{this, "RemovePlateFromSite"},
m_SitesProperty{this, "Sites"}
{
    FileManager::checkAndCreateDir(m_ColObjDir);
    loadCollisionObjectsIntoScene(m_PlanningScene);

    FileManager::checkAndCreateDir(m_SitesDir);
    loadSiteFilesIntoMap(m_Sites);
    std::vector<SiLA2::CString> siteIds;
    for (auto const& elem : this->m_Sites) {
        // collect IDs
        siteIds.push_back(SiLA2::CString(elem.first));
    }
    m_SitesProperty.setValue(siteIds);
    m_GetSiteCommand.setExecutor(this, &CSiteManagerImpl::GetSite);
    m_SetSiteCommand.setExecutor(this, &CSiteManagerImpl::SetSite);
    m_DeleteSiteCommand.setExecutor(this, &CSiteManagerImpl::DeleteSite);
    m_IsSiteOccupiedCommand.setExecutor(this, &CSiteManagerImpl::IsSiteOccupied);
    m_PutPlateOnSiteCommand.setExecutor(this, &CSiteManagerImpl::PutPlateOnSite);
    m_RemovePlateFromSiteCommand.setExecutor(this, &CSiteManagerImpl::RemovePlateFromSite);
}

GetSite_Responses CSiteManagerImpl::GetSite(GetSiteWrapper* command) {
    const auto request = command->parameters();
    const std::string& siteId = request.siteid().siteid().value();
    if (!hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    /* TODO: This is just a temporary hack where all values gat dumped into a string just to be 
     * able to show them to the user. (2021-01-27, florian.bauer.dev@gmail.com) 
     */
    const Site& site = getSite(siteId);
    auto response = GetSite_Responses{};
    response.mutable_site()->set_value(site.toJson().dump());
    return response;
}

SetSite_Responses CSiteManagerImpl::SetSite(SetSiteWrapper* command) {
    const auto request = command->parameters();
    const std::string& idToSet = request.siteid().siteid().value();
    const auto iter = m_Sites.find(idToSet);
    const bool isSiteIdInList = (iter != m_Sites.cend());
    if (!isSiteIdInList) {
        // Add a new ID to property list.
        m_SitesProperty.append(request.siteid().siteid());
    }

    Site site = (!isSiteIdInList) ? Site(idToSet) : iter->second;
    const auto& pose = request.pose().pose();
    geometry_msgs::Pose rosPose;
    rosPose.position.x = pose.x().value();
    rosPose.position.y = pose.y().value();
    rosPose.position.z = pose.z().value();
    rosPose.orientation.x = pose.orix().value();
    rosPose.orientation.y = pose.oriy().value();
    rosPose.orientation.z = pose.oriz().value();
    rosPose.orientation.w = pose.oriw().value();
    site.setPose(rosPose);

    const auto& approachMove = request.approach().relativemove();
    moveit_msgs::GripperTranslation approach;
    approach.desired_distance = approachMove.desireddist().value() * CM_TO_M;
    approach.min_distance = approachMove.mindist().value() * CM_TO_M;
    approach.direction.vector.x = approachMove.x().value();
    approach.direction.vector.y = approachMove.y().value();
    approach.direction.vector.z = approachMove.z().value();
    site.setApproach(approach);

    if (!request.retreat().empty()) {
        const auto& retreatMove = request.retreat().at(0).relativemove();
        moveit_msgs::GripperTranslation retreat;
        retreat.desired_distance = retreatMove.desireddist().value() * CM_TO_M;
        retreat.min_distance = retreatMove.mindist().value() * CM_TO_M;
        retreat.direction.vector.x = retreatMove.x().value();
        retreat.direction.vector.y = retreatMove.y().value();
        retreat.direction.vector.z = retreatMove.z().value();
        site.setRetreat(retreat);
    }

    // Add/update entry in map.
    m_Sites.insert({idToSet, site});
    // Write JSON data to file.
    const fs::path jsonFile = m_SitesDir / (idToSet + JSON_FILE_EXT);
    FileManager::saveJsonToFile(site.toJson(), jsonFile);

    return SetSite_Responses{};
}

DeleteSite_Responses CSiteManagerImpl::DeleteSite(DeleteSiteWrapper* command) {
    const auto request = command->parameters();
    const std::string& idToDelete = request.siteid().siteid().value();
    const auto iter = m_Sites.find(idToDelete);
    const bool isSiteIdInList = (iter != m_Sites.cend());
    if (isSiteIdInList) {
        m_Sites.erase(iter);
        std::vector<SiLA2::CString> siteIds;
        for (auto const& elem : m_Sites) {
            // collect IDs
            siteIds.push_back(SiLA2::CString(elem.first));
        }
        m_SitesProperty.setValue(siteIds);
        const fs::path jsonFile = m_SitesDir / (idToDelete + JSON_FILE_EXT);
        fs::remove(jsonFile);
    } else {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    return DeleteSite_Responses{};
}

IsSiteOccupied_Responses CSiteManagerImpl::IsSiteOccupied(IsSiteOccupiedWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& id = request.siteid().siteid().value();

    if (!hasSiteId(id)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    const Site& site = getSite(id);
    auto response = IsSiteOccupied_Responses{};
    response.mutable_isoccupied()->set_value(site.isOccupied());
    return response;
}

PutPlateOnSite_Responses CSiteManagerImpl::PutPlateOnSite(PutPlateOnSiteWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;
    const std::string& plateTypeId = request.platetypeid().platetypeid().value();
    if (!m_PlateTypeManagerPtr->hasPlateTypeId(plateTypeId)) {
        throw ERROR_PLATE_TYPE_ID_NOT_FOUND;
    }

    const std::string& siteId = request.siteid().siteid().value();
    if (!hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    Site& site = getSite(siteId);
    if (site.isOccupied()) {
        throw ERROR_ALREADY_OCCUPIED;
    }

    auto plate = m_PlateTypeManagerPtr->createSharedPlate(plateTypeId);
    site.putPlate(plate);
    m_PlanningScene.applyCollisionObject(plate->getCollisonObject());
    site.setOccupied(true);

    return PutPlateOnSite_Responses{};
}

RemovePlateFromSite_Responses CSiteManagerImpl::RemovePlateFromSite(RemovePlateFromSiteWrapper* command) {
    const auto request = command->parameters();
    qDebug() << "Request contains:" << request;

    const std::string& siteId = request.siteid().siteid().value();
    if (!hasSiteId(siteId)) {
        throw ERROR_SITE_ID_NOT_FOUND;
    }

    Site& site = getSite(siteId);
    if (!site.isOccupied()) {
        throw ERROR_SITE_IS_EMPTY;
    }

    m_PlanningScene.removeCollisionObjects({site.getPlate()->getObjectId()});
    site.removePlate();
    site.setOccupied(false);

    return RemovePlateFromSite_Responses{};
}

/**
 * Checks if the given site ID is available.
 * 
 * @param siteId The site ID to check.
 * @return true if the site ID is known, otherwise false.
 */
bool CSiteManagerImpl::hasSiteId(const std::string& siteId) const {
    return (m_Sites.find(siteId) != m_Sites.cend());
}

/**
 * Get the site object with the site ID. No validation of the ID is made.
 * 
 * @param siteId The site ID for the site to get.
 * @return The site object for further usage.
 */
Site& CSiteManagerImpl::getSite(const std::string& siteId) {
    const std::map<std::string, Site>::iterator iter = m_Sites.find(siteId);
    return iter->second;
}
