//============================================================================
/// \file    SiteManagerImpl.cpp
/// \authors Florian Bauer <florian.bauer.dev@gmail.com>
/// \date    2021-01-10
/// \brief   Declaration of the CSiteManagerImpl class
/// \note    Code generated by sila2codegenerator 0.3.3-dev
//============================================================================
#include <iostream>
#include <fstream>
#include <sila_cpp/common/logging.h>
#include "SiteManagerImpl.h"
#include "FileManager.h"
#include "SiteManager.pb.h"

namespace fs = std::filesystem;
using namespace sila2::de::fau::robot::sitemanager::v1;
using json = nlohmann::json;

// Field identifiers for JSON de-/serialization.
static constexpr char SITE_ID[] = "id";
static constexpr char POSE[] = "pose";
static constexpr char POS_X[] = "posX";
static constexpr char POS_Y[] = "posY";
static constexpr char POS_Z[] = "posZ";
static constexpr char ORI_X[] = "oriX";
static constexpr char ORI_Y[] = "oriY";
static constexpr char ORI_Z[] = "oriZ";
static constexpr char ORI_W[] = "oriW";

std::map<std::string, json> CSiteManagerImpl::loadJsonFilesToMap() {
    const fs::path appDir = FileManager::getAppDir();
    const fs::path sitesDir = appDir / SITES_DIR;
    FileManager::checkAndCreateDir(sitesDir);

    std::map<std::string, json> sites;
    const std::vector<fs::path> sitesFiles = FileManager::collectJsonFilesFromDir(sitesDir);
    for (const auto& file : sitesFiles) {
        // read a JSON file
        std::ifstream jsonStream(file);
        json jsonStruct;
        try {
            jsonStream >> jsonStruct;
        } catch (const std::exception& ex) {
            std::cerr << "Could not load: " << file << "\n" << ex.what();
            jsonStream.close();
            continue;
        }
        jsonStream.close();

        const std::string& id = jsonStruct[SITE_ID].get<std::string>();
        sites[id] = jsonStruct;
    }
    return sites;
}

CSiteManagerImpl::CSiteManagerImpl(SiLA2::CSiLAServer* parent)
: CSiLAFeature{parent}
, m_SetSiteCommand{this, "SetSite"}
, m_DeleteSiteCommand{this, "DeleteSite"}
, m_SitesProperty{this, "Sites"}
, m_JsonSites(loadJsonFilesToMap()) {

    std::vector<SiLA2::CString> siteIds;
    for (auto const& elem : m_JsonSites) {
        // collect IDs
        siteIds.push_back(SiLA2::CString(elem.first));
    }
    m_SitesProperty.setValue(siteIds);
    m_SetSiteCommand.setExecutor(this, &CSiteManagerImpl::SetSite);
    m_DeleteSiteCommand.setExecutor(this, &CSiteManagerImpl::DeleteSite);
}

SetSite_Responses CSiteManagerImpl::SetSite(SetSiteWrapper* command) {
    const auto request = command->parameters();
    const std::string& idToSet = request.siteid().siteid().value();
    const auto iter = m_JsonSites.find(idToSet);
    json jsonStruct;
    const bool isSiteIdInList = (iter != m_JsonSites.end());
    const auto& pose = request.pose().pose();
    if (isSiteIdInList) {
        jsonStruct = iter->second;
        jsonStruct[POSE] = {
            {POS_X, pose.x().value()},
            {POS_Y, pose.y().value()},
            {POS_Z, pose.z().value()},
            {ORI_X, pose.orix().value()},
            {ORI_Y, pose.oriy().value()},
            {ORI_Z, pose.oriz().value()},
            {ORI_W, pose.oriw().value()},
        };
    } else {
        // Add a new ID to property list.
        m_SitesProperty.append(request.siteid().siteid());
        jsonStruct[SITE_ID] = idToSet;
        jsonStruct[POSE] = {
            {POS_X, pose.x().value()},
            {POS_Y, pose.y().value()},
            {POS_Z, pose.z().value()},
            {ORI_X, pose.orix().value()},
            {ORI_Y, pose.oriy().value()},
            {ORI_Z, pose.oriz().value()},
            {ORI_W, pose.oriw().value()},
        };
        // Add entry to map.
        m_JsonSites[idToSet] = jsonStruct;
    }

    // Write JSON data to file.
    const fs::path jsonFile = FileManager::getAppDir() / SITES_DIR / (idToSet + JSON_FILE_EXT);
    FileManager::saveJsonToFile(jsonStruct, jsonFile);

    return SetSite_Responses{};
}

DeleteSite_Responses CSiteManagerImpl::DeleteSite(DeleteSiteWrapper* command) {
    const auto request = command->parameters();
    const std::string& idToDelete = request.siteid().siteid().value();
    const auto iter = m_JsonSites.find(idToDelete);
    const bool isSiteIdInList = (iter != m_JsonSites.end());
    if (isSiteIdInList) {
        m_JsonSites.erase(iter);
        std::vector<SiLA2::CString> siteIds;
        for (auto const& elem : m_JsonSites) {
            // collect IDs
            siteIds.push_back(SiLA2::CString(elem.first));
        }
        m_SitesProperty.setValue(siteIds);
        const fs::path jsonFile = FileManager::getAppDir() / SITES_DIR / (idToDelete + JSON_FILE_EXT);
        fs::remove(jsonFile);
    } else {
        throw SiLA2::CDefinedExecutionError{
            "SiteIdNotFound",
            "The given Site ID does not exist or could not be found."};
    }

    return DeleteSite_Responses{};
}
